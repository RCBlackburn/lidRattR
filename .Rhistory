fullvox$I_list[do.call(rbind,null_list)] <- NA
##### Individual voxel metrics
### FR_SVi is the frequency ratio of the number of returns in a voxel in relation to total returns (in Pearse et al. 2019 this is FR_Di)
fullvox <- fullvox %>% mutate(FR_SVi = SVi/sum(fullvox$SVi))
### P_Di is the number of returns below each voxel (Pearse et al. 2019; Kim et al. 2016 uses returns above)
# create a vector for Z in each iteration
Zi = fullvox$Z
# for loop to calculate points below each voxel
point_blow = list()
for(i in 1:length(unique(fullvox$Z))){
np_b <- fullvox %>%
group_by(X,Y) %>%
filter(Z < unique(Z)[i]) %>%
summarize(npoints_below = sum(SVi), Z= unique(Zi)[i])
point_blow[[i]] <- np_b
}
# extract point below data and merge using the voxel id
point_blow_all_vox <- do.call(rbind,point_blow)
point_blow_all_vox <- point_blow_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_blow_all_vox[,c(3,5)]), by = "id_xyz", )
### P_Di_above is the number of returns above each voxel (Kim et al. 2016 uses returns above as P_Di)
# for loop to calculate points below each voxel
point_above = list()
for(i in 1:length(unique(fullvox$Z))){
np_a <- fullvox %>%
group_by(X,Y) %>%
filter(Z > unique(Z)[i]) %>%
summarize(npoints_above = sum(SVi, na.rm = T), Z= unique(Zi)[i])
point_above[[i]] <- np_a
}
# extract point below data and merge using the voxel id
point_above_all_vox <- do.call(rbind,point_above)
point_above_all_vox <- point_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_above_all_vox[,c(3,5)]), by = "id_xyz", )
# NAs returned for 0 points so it is appropriate to replace them with 0
fullvox$npoints_above[is.na(fullvox$npoints_above)] <- 0
### FR_Di is the frequency ratio of the number of returns above a voxel in relation to total returns (Kim et al. 2016)
fullvox <- fullvox %>% mutate(FR_Di = npoints_above/sum(fullvox$SVi))
### I_Di is the median intensity of returns above each voxel
# for loop to calculate median intensity above each voxel
i_above = list()
for(i in 1:length(unique(fullvox$Z))){
i_a <- fullvox %>% filter(Z > Z[i])
i_a$I_list<- lapply( i_a$I_list, "length<-", max(lengths( i_a$I_list)))
i_abv <- as.data.frame(do.call(rbind, i_a$I_list))
i_a_merge <- cbind(as.data.frame(i_a), i_abv)
i_a_merge <- cbind(X = i_a_merge$X, Y = i_a_merge$Y, i_a_merge[,ncol(i_a)+1:(ncol(i_a_merge)-ncol(i_a))])
i_Di_mt <- i_a_merge %>% pivot_longer(cols = 3:ncol(i_a_merge)) %>%
group_by(X,Y) %>%
summarize(Z = unique(fullvox$Z)[i], i_Di = median(value, na.rm = T))
i_above[[i]] <- i_Di_mt
}
# extract point below data and merge using the voxel id
i_above_all_vox <- do.call(rbind,i_above)
i_above_all_vox <- i_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(i_above_all_vox[,c(4,5)]), by = "id_xyz" )
return(fullvox)
}
std_voxel_all(low, resolution = 1)
library(tidyverse)
std_voxel_all(low, resolution = 1)
c(min(vox$X), max(vox$X))
vox_xc(min(vox$X), max(vox$X))
vox_x <- c(min(vox$X), max(vox$X))
vox_y <- c(min(vox$Y), max(vox$Y))
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
x
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
vox_ht = max(vox$Z)
z = seq(min(vox$Z), vox_ht, resolution)
all_vox = expand.grid(X = x, Y = y, Z = z)
data.table::setDT(all_vox)
# merge all and voxel_metrics() output
fullvox = vox[all_vox, on = c("X", "Y", "Z")]
# give each voxel a unique id and assign 0s and NAs where appropriate
fullvox <- fullvox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox$SVi[is.na(fullvox$SVi)] <- 0
null_list <- lapply(fullvox$Z_list,is.null)
fullvox$Z_list[do.call(rbind,null_list)] <- NA
fullvox$I_list[do.call(rbind,null_list)] <- NA
##### Individual voxel metrics
### FR_SVi is the frequency ratio of the number of returns in a voxel in relation to total returns (in Pearse et al. 2019 this is FR_Di)
fullvox <- fullvox %>% mutate(FR_SVi = SVi/sum(fullvox$SVi))
### P_Di is the number of returns below each voxel (Pearse et al. 2019; Kim et al. 2016 uses returns above)
# create a vector for Z in each iteration
Zi = fullvox$Z
# for loop to calculate points below each voxel
point_blow = list()
for(i in 1:length(unique(fullvox$Z))){
np_b <- fullvox %>%
group_by(X,Y) %>%
filter(Z < unique(Z)[i]) %>%
summarize(npoints_below = sum(SVi), Z= unique(Zi)[i])
point_blow[[i]] <- np_b
}
# extract point below data and merge using the voxel id
point_blow_all_vox <- do.call(rbind,point_blow)
point_blow_all_vox <- point_blow_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_blow_all_vox[,c(3,5)]), by = "id_xyz", )
### P_Di_above is the number of returns above each voxel (Kim et al. 2016 uses returns above as P_Di)
# for loop to calculate points below each voxel
point_above = list()
for(i in 1:length(unique(fullvox$Z))){
np_a <- fullvox %>%
group_by(X,Y) %>%
filter(Z > unique(Z)[i]) %>%
summarize(npoints_above = sum(SVi, na.rm = T), Z= unique(Zi)[i])
point_above[[i]] <- np_a
}
# extract point below data and merge using the voxel id
point_above_all_vox <- do.call(rbind,point_above)
point_above_all_vox <- point_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_above_all_vox[,c(3,5)]), by = "id_xyz", )
# NAs returned for 0 points so it is appropriate to replace them with 0
fullvox$npoints_above[is.na(fullvox$npoints_above)] <- 0
### FR_Di is the frequency ratio of the number of returns above a voxel in relation to total returns (Kim et al. 2016)
fullvox <- fullvox %>% mutate(FR_Di = npoints_above/sum(fullvox$SVi))
### I_Di is the median intensity of returns above each voxel
# for loop to calculate median intensity above each voxel
i_above = list()
for(i in 1:length(unique(fullvox$Z))){
i_a <- fullvox %>% filter(Z > Z[i])
i_a$I_list<- lapply( i_a$I_list, "length<-", max(lengths( i_a$I_list)))
i_abv <- as.data.frame(do.call(rbind, i_a$I_list))
i_a_merge <- cbind(as.data.frame(i_a), i_abv)
i_a_merge <- cbind(X = i_a_merge$X, Y = i_a_merge$Y, i_a_merge[,ncol(i_a)+1:(ncol(i_a_merge)-ncol(i_a))])
i_Di_mt <- i_a_merge %>% pivot_longer(cols = 3:ncol(i_a_merge)) %>%
group_by(X,Y) %>%
summarize(Z = unique(fullvox$Z)[i], i_Di = median(value, na.rm = T))
i_above[[i]] <- i_Di_mt
}
# extract point below data and merge using the voxel id
i_above_all_vox <- do.call(rbind,i_above)
i_above_all_vox <- i_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(i_above_all_vox[,c(4,5)]), by = "id_xyz" )
std_voxel_all <- function(las, resolution, vox_ht = max(vox$Z), vox_x = c(min(vox$X), max(vox$X)), vox_y = c(min(vox$X), max(vox$X))){
vox <- lidR::voxel_metrics(las, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
all_vox = expand.grid(X = x, Y = y, Z = z)
data.table::setDT(all_vox)
# merge all and voxel_metrics() output
fullvox = vox[all_vox, on = c("X", "Y", "Z")]
# give each voxel a unique id and assign 0s and NAs where appropriate
fullvox <- fullvox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox$SVi[is.na(fullvox$SVi)] <- 0
null_list <- lapply(fullvox$Z_list,is.null)
fullvox$Z_list[do.call(rbind,null_list)] <- NA
fullvox$I_list[do.call(rbind,null_list)] <- NA
##### Individual voxel metrics
### FR_SVi is the frequency ratio of the number of returns in a voxel in relation to total returns (in Pearse et al. 2019 this is FR_Di)
fullvox <- fullvox %>% mutate(FR_SVi = SVi/sum(fullvox$SVi))
### P_Di is the number of returns below each voxel (Pearse et al. 2019; Kim et al. 2016 uses returns above)
# create a vector for Z in each iteration
Zi = fullvox$Z
# for loop to calculate points below each voxel
point_blow = list()
for(i in 1:length(unique(fullvox$Z))){
np_b <- fullvox %>%
group_by(X,Y) %>%
filter(Z < unique(Z)[i]) %>%
summarize(npoints_below = sum(SVi), Z= unique(Zi)[i])
point_blow[[i]] <- np_b
}
# extract point below data and merge using the voxel id
point_blow_all_vox <- do.call(rbind,point_blow)
point_blow_all_vox <- point_blow_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_blow_all_vox[,c(3,5)]), by = "id_xyz", )
### P_Di_above is the number of returns above each voxel (Kim et al. 2016 uses returns above as P_Di)
# for loop to calculate points below each voxel
point_above = list()
for(i in 1:length(unique(fullvox$Z))){
np_a <- fullvox %>%
group_by(X,Y) %>%
filter(Z > unique(Z)[i]) %>%
summarize(npoints_above = sum(SVi, na.rm = T), Z= unique(Zi)[i])
point_above[[i]] <- np_a
}
# extract point below data and merge using the voxel id
point_above_all_vox <- do.call(rbind,point_above)
point_above_all_vox <- point_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_above_all_vox[,c(3,5)]), by = "id_xyz", )
# NAs returned for 0 points so it is appropriate to replace them with 0
fullvox$npoints_above[is.na(fullvox$npoints_above)] <- 0
### FR_Di is the frequency ratio of the number of returns above a voxel in relation to total returns (Kim et al. 2016)
fullvox <- fullvox %>% mutate(FR_Di = npoints_above/sum(fullvox$SVi))
### I_Di is the median intensity of returns above each voxel
# for loop to calculate median intensity above each voxel
i_above = list()
for(i in 1:length(unique(fullvox$Z))){
i_a <- fullvox %>% filter(Z > Z[i])
i_a$I_list<- lapply( i_a$I_list, "length<-", max(lengths( i_a$I_list)))
i_abv <- as.data.frame(do.call(rbind, i_a$I_list))
i_a_merge <- cbind(as.data.frame(i_a), i_abv)
i_a_merge <- cbind(X = i_a_merge$X, Y = i_a_merge$Y, i_a_merge[,ncol(i_a)+1:(ncol(i_a_merge)-ncol(i_a))])
i_Di_mt <- i_a_merge %>% pivot_longer(cols = 3:ncol(i_a_merge)) %>%
group_by(X,Y) %>%
summarize(Z = unique(fullvox$Z)[i], i_Di = median(value, na.rm = T))
i_above[[i]] <- i_Di_mt
}
# extract point below data and merge using the voxel id
i_above_all_vox <- do.call(rbind,i_above)
i_above_all_vox <- i_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(i_above_all_vox[,c(4,5)]), by = "id_xyz" )
return(fullvox)
}
low %>% lasfilter(Classification == 1)
low_veg <- low %>% lasfilter(Classification == 1)
plot(low_veg)
std_voxel_all(low_veg, 5)
std_voxel_all(low_veg, 5)
vox <- lidR::voxel_metrics(low_veg, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
std_voxel_all(low_veg, 5)1
vox <- lidR::voxel_metrics(low_veg, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
all_vox = expand.grid(X = x, Y = y, Z = z)
data.table::setDT(all_vox)
# merge all and voxel_metrics() output
fullvox = vox[all_vox, on = c("X", "Y", "Z")]
plot(fullvox)
std_voxel_all <- function(las, resolution, vox_ht = max(vox$Z), vox_x = c(min(vox$X), max(vox$X)), vox_y = c(min(vox$X), max(vox$X))){
vox <- lidR::voxel_metrics(low_veg, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
all_vox = expand.grid(X = x, Y = y, Z = z)
data.table::setDT(all_vox)
# merge all and voxel_metrics() output
fullvox = vox[all_vox, on = c("X", "Y", "Z")]
# give each voxel a unique id and assign 0s and NAs where appropriate
fullvox <- fullvox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox$SVi[is.na(fullvox$SVi)] <- 0
null_list <- lapply(fullvox$Z_list,is.null)
fullvox$Z_list[do.call(rbind,null_list)] <- NA
fullvox$I_list[do.call(rbind,null_list)] <- NA
##### Individual voxel metrics
### FR_SVi is the frequency ratio of the number of returns in a voxel in relation to total returns (in Pearse et al. 2019 this is FR_Di)
fullvox <- fullvox %>% mutate(FR_SVi = SVi/sum(fullvox$SVi))
### P_Di is the number of returns below each voxel (Pearse et al. 2019; Kim et al. 2016 uses returns above)
# create a vector for Z in each iteration
Zi = fullvox$Z
# for loop to calculate points below each voxel
point_blow = list()
for(i in 1:length(unique(fullvox$Z))){
np_b <- fullvox %>%
group_by(X,Y) %>%
filter(Z < unique(Z)[i]) %>%
summarize(npoints_below = sum(SVi), Z= unique(Zi)[i])
point_blow[[i]] <- np_b
}
# extract point below data and merge using the voxel id
point_blow_all_vox <- do.call(rbind,point_blow)
point_blow_all_vox <- point_blow_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_blow_all_vox[,c(3,5)]), by = "id_xyz", )
### P_Di_above is the number of returns above each voxel (Kim et al. 2016 uses returns above as P_Di)
# for loop to calculate points below each voxel
point_above = list()
for(i in 1:length(unique(fullvox$Z))){
np_a <- fullvox %>%
group_by(X,Y) %>%
filter(Z > unique(Z)[i]) %>%
summarize(npoints_above = sum(SVi, na.rm = T), Z= unique(Zi)[i])
point_above[[i]] <- np_a
}
# extract point below data and merge using the voxel id
point_above_all_vox <- do.call(rbind,point_above)
point_above_all_vox <- point_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_above_all_vox[,c(3,5)]), by = "id_xyz", )
# NAs returned for 0 points so it is appropriate to replace them with 0
fullvox$npoints_above[is.na(fullvox$npoints_above)] <- 0
### FR_Di is the frequency ratio of the number of returns above a voxel in relation to total returns (Kim et al. 2016)
fullvox <- fullvox %>% mutate(FR_Di = npoints_above/sum(fullvox$SVi))
### I_Di is the median intensity of returns above each voxel
# for loop to calculate median intensity above each voxel
i_above = list()
for(i in 1:length(unique(fullvox$Z))){
i_a <- fullvox %>% filter(Z > Z[i])
i_a$I_list<- lapply( i_a$I_list, "length<-", max(lengths( i_a$I_list)))
i_abv <- as.data.frame(do.call(rbind, i_a$I_list))
i_a_merge <- cbind(as.data.frame(i_a), i_abv)
i_a_merge <- cbind(X = i_a_merge$X, Y = i_a_merge$Y, i_a_merge[,ncol(i_a)+1:(ncol(i_a_merge)-ncol(i_a))])
i_Di_mt <- i_a_merge %>% pivot_longer(cols = 3:ncol(i_a_merge)) %>%
group_by(X,Y) %>%
summarize(Z = unique(fullvox$Z)[i], i_Di = median(value, na.rm = T))
i_above[[i]] <- i_Di_mt
}
# extract point below data and merge using the voxel id
i_above_all_vox <- do.call(rbind,i_above)
i_above_all_vox <- i_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(i_above_all_vox[,c(4,5)]), by = "id_xyz" )
return(fullvox)
}
std_voxel_all <- function(las, resolution, vox_ht = max(vox$Z), vox_x = c(min(vox$X), max(vox$X)), vox_y = c(min(vox$X), max(vox$X))){
vox <- lidR::voxel_metrics(las, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
all_vox = expand.grid(X = x, Y = y, Z = z)
data.table::setDT(all_vox)
# merge all and voxel_metrics() output
fullvox = vox[all_vox, on = c("X", "Y", "Z")]
# give each voxel a unique id and assign 0s and NAs where appropriate
fullvox <- fullvox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox$SVi[is.na(fullvox$SVi)] <- 0
null_list <- lapply(fullvox$Z_list,is.null)
fullvox$Z_list[do.call(rbind,null_list)] <- NA
fullvox$I_list[do.call(rbind,null_list)] <- NA
##### Individual voxel metrics
### FR_SVi is the frequency ratio of the number of returns in a voxel in relation to total returns (in Pearse et al. 2019 this is FR_Di)
fullvox <- fullvox %>% mutate(FR_SVi = SVi/sum(fullvox$SVi))
### P_Di is the number of returns below each voxel (Pearse et al. 2019; Kim et al. 2016 uses returns above)
# create a vector for Z in each iteration
Zi = fullvox$Z
# for loop to calculate points below each voxel
point_blow = list()
for(i in 1:length(unique(fullvox$Z))){
np_b <- fullvox %>%
group_by(X,Y) %>%
filter(Z < unique(Z)[i]) %>%
summarize(npoints_below = sum(SVi), Z= unique(Zi)[i])
point_blow[[i]] <- np_b
}
# extract point below data and merge using the voxel id
point_blow_all_vox <- do.call(rbind,point_blow)
point_blow_all_vox <- point_blow_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_blow_all_vox[,c(3,5)]), by = "id_xyz", )
### P_Di_above is the number of returns above each voxel (Kim et al. 2016 uses returns above as P_Di)
# for loop to calculate points below each voxel
point_above = list()
for(i in 1:length(unique(fullvox$Z))){
np_a <- fullvox %>%
group_by(X,Y) %>%
filter(Z > unique(Z)[i]) %>%
summarize(npoints_above = sum(SVi, na.rm = T), Z= unique(Zi)[i])
point_above[[i]] <- np_a
}
# extract point below data and merge using the voxel id
point_above_all_vox <- do.call(rbind,point_above)
point_above_all_vox <- point_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_above_all_vox[,c(3,5)]), by = "id_xyz", )
# NAs returned for 0 points so it is appropriate to replace them with 0
fullvox$npoints_above[is.na(fullvox$npoints_above)] <- 0
### FR_Di is the frequency ratio of the number of returns above a voxel in relation to total returns (Kim et al. 2016)
fullvox <- fullvox %>% mutate(FR_Di = npoints_above/sum(fullvox$SVi))
### I_Di is the median intensity of returns above each voxel
# for loop to calculate median intensity above each voxel
i_above = list()
for(i in 1:length(unique(fullvox$Z))){
i_a <- fullvox %>% filter(Z > Z[i])
i_a$I_list<- lapply( i_a$I_list, "length<-", max(lengths( i_a$I_list)))
i_abv <- as.data.frame(do.call(rbind, i_a$I_list))
i_a_merge <- cbind(as.data.frame(i_a), i_abv)
i_a_merge <- cbind(X = i_a_merge$X, Y = i_a_merge$Y, i_a_merge[,ncol(i_a)+1:(ncol(i_a_merge)-ncol(i_a))])
i_Di_mt <- i_a_merge %>% pivot_longer(cols = 3:ncol(i_a_merge)) %>%
group_by(X,Y) %>%
summarize(Z = unique(fullvox$Z)[i], i_Di = median(value, na.rm = T))
i_above[[i]] <- i_Di_mt
}
# extract point below data and merge using the voxel id
i_above_all_vox <- do.call(rbind,i_above)
i_above_all_vox <- i_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(i_above_all_vox[,c(4,5)]), by = "id_xyz" )
return(fullvox)
}
vox_mt <- function(z, i)
{
metrics =list(
SVi = length(z), # number of points in a voxel (notation from Pearse et al. 2019)
med_z_vox = median(z),
mean_z_vox = mean(z),
var_z_vox = var(z),
sd_z_vox = sd(z),
cv_z_vox = sd(z)/mean(z),
IQR_z_vox = IQR(z),
skew_z_vox = e1071::skewness(z),
kurt_z_vox = e1071::kurtosis(z),
med_i_vox = median(i),
mean_i_vox = mean(i),
var_i_vox = var(i),
sd_i_vox = sd(i),
cv_i_vox = sd(i)/mean(i),
IQR_i_vox = IQR(i),
skew_i_vox = e1071::skewness(i),
kurt_i_vox = e1071::kurtosis(i),
Z_list = list(z),
I_list = list(as.numeric(i))
)
return(metrics)
}
low <- readLAS("viz/low_density.las")
med <- readLAS("viz/med_density.las")
std_voxel_all(med, 5)
vox <- lidR::voxel_metrics(las, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
all_vox = expand.grid(X = x, Y = y, Z = z)
lidR::voxel_metrics(med, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
lidR::voxel_metrics(med, func = vox_mt(Z, as.numeric(Intensity)), res 1)
lidR::voxel_metrics(med, func = vox_mt(Z, as.numeric(Intensity)), res =1)
vox <-  lidR::voxel_metrics(med, func = vox_mt(Z, as.numeric(Intensity)), res =1)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
vox_x = c(min(vox$X), max(vox$X))
vox_y = c(min(vox$X)
)
vox_ht = max(vox$Z)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
resolution = 1
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
resolution
vox_x
y = seq(vox_y[1], vox_y[2], resolution)
vox_y[1]
vox_y[2]
vox_y = c(min(vox$Y), max(vox$Y)
y = seq(vox_y[1], vox_y[2], resolution)
vox_y = c(min(vox$Y), max(vox$Y))
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
std_voxel_all <- function(las, resolution, vox_ht = max(vox$Z), vox_x = c(min(vox$X), max(vox$X)), vox_y = c(min(vox$Y), max(vox$Y))){
vox <- lidR::voxel_metrics(las, func = vox_mt(Z, as.numeric(Intensity)), res = resolution)
# create all possible voxels
x = seq(vox_x[1], vox_x[2], resolution)
y = seq(vox_y[1], vox_y[2], resolution)
z = seq(min(vox$Z), vox_ht, resolution)
all_vox = expand.grid(X = x, Y = y, Z = z)
data.table::setDT(all_vox)
# merge all and voxel_metrics() output
fullvox = vox[all_vox, on = c("X", "Y", "Z")]
# give each voxel a unique id and assign 0s and NAs where appropriate
fullvox <- fullvox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox$SVi[is.na(fullvox$SVi)] <- 0
null_list <- lapply(fullvox$Z_list,is.null)
fullvox$Z_list[do.call(rbind,null_list)] <- NA
fullvox$I_list[do.call(rbind,null_list)] <- NA
##### Individual voxel metrics
### FR_SVi is the frequency ratio of the number of returns in a voxel in relation to total returns (in Pearse et al. 2019 this is FR_Di)
fullvox <- fullvox %>% mutate(FR_SVi = SVi/sum(fullvox$SVi))
### P_Di is the number of returns below each voxel (Pearse et al. 2019; Kim et al. 2016 uses returns above)
# create a vector for Z in each iteration
Zi = fullvox$Z
# for loop to calculate points below each voxel
point_blow = list()
for(i in 1:length(unique(fullvox$Z))){
np_b <- fullvox %>%
group_by(X,Y) %>%
filter(Z < unique(Z)[i]) %>%
summarize(npoints_below = sum(SVi), Z= unique(Zi)[i])
point_blow[[i]] <- np_b
}
# extract point below data and merge using the voxel id
point_blow_all_vox <- do.call(rbind,point_blow)
point_blow_all_vox <- point_blow_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_blow_all_vox[,c(3,5)]), by = "id_xyz", )
### P_Di_above is the number of returns above each voxel (Kim et al. 2016 uses returns above as P_Di)
# for loop to calculate points below each voxel
point_above = list()
for(i in 1:length(unique(fullvox$Z))){
np_a <- fullvox %>%
group_by(X,Y) %>%
filter(Z > unique(Z)[i]) %>%
summarize(npoints_above = sum(SVi, na.rm = T), Z= unique(Zi)[i])
point_above[[i]] <- np_a
}
# extract point below data and merge using the voxel id
point_above_all_vox <- do.call(rbind,point_above)
point_above_all_vox <- point_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(point_above_all_vox[,c(3,5)]), by = "id_xyz", )
# NAs returned for 0 points so it is appropriate to replace them with 0
fullvox$npoints_above[is.na(fullvox$npoints_above)] <- 0
### FR_Di is the frequency ratio of the number of returns above a voxel in relation to total returns (Kim et al. 2016)
fullvox <- fullvox %>% mutate(FR_Di = npoints_above/sum(fullvox$SVi))
### I_Di is the median intensity of returns above each voxel
# for loop to calculate median intensity above each voxel
i_above = list()
for(i in 1:length(unique(fullvox$Z))){
i_a <- fullvox %>% filter(Z > Z[i])
i_a$I_list<- lapply( i_a$I_list, "length<-", max(lengths( i_a$I_list)))
i_abv <- as.data.frame(do.call(rbind, i_a$I_list))
i_a_merge <- cbind(as.data.frame(i_a), i_abv)
i_a_merge <- cbind(X = i_a_merge$X, Y = i_a_merge$Y, i_a_merge[,ncol(i_a)+1:(ncol(i_a_merge)-ncol(i_a))])
i_Di_mt <- i_a_merge %>% pivot_longer(cols = 3:ncol(i_a_merge)) %>%
group_by(X,Y) %>%
summarize(Z = unique(fullvox$Z)[i], i_Di = median(value, na.rm = T))
i_above[[i]] <- i_Di_mt
}
# extract point below data and merge using the voxel id
i_above_all_vox <- do.call(rbind,i_above)
i_above_all_vox <- i_above_all_vox %>% mutate(id_xyz = paste0(X,"-",Y,"-",Z))
fullvox <- fullvox %>% left_join(as.data.frame(i_above_all_vox[,c(4,5)]), by = "id_xyz" )
return(fullvox)
}
med <- readLAS("viz/med_density.las")
med <- med %>% lasfilter(Classification == 1)
std_voxel_all(med, res = 1)
devtools::document()
